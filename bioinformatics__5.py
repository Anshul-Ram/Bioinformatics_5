# -*- coding: utf-8 -*-
"""Bioinformatics_#5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cq_zYsOP7cL3DeYnCtUZ-bfZKL2C3a7Q

# Week 5
"""

DNA = input( "Input the gneome: " )
DNA = DNA.split()

"""# Needed to remove the string at the beginning of each of the DNA strings."""

DNA_prime = []


for i in range( len( DNA ) ):

  if i % 2 == 1:

    DNA_prime.append( DNA[ i ] )


DNA = DNA_prime


print( DNA[ 0:5 ] )

"""# The Hamming distance function once again."""

def HammingDistanceArray( fg, sg ):


  distance = 0

  for i in range( len( fg ) ):

    for j in range( len(fg[0]) ):

      
      if list( fg[ i ] ) [ j ] != sg[ j ]:
        distance += 1

  return distance

"""# Adapting the randomized motif search from the previous notebooks for this weeks quiz."""

#DNA = input("DNA strings: ").split()

k = int( input("k: ") )

initial_motif_matrix = [ string[0:k] for string in DNA ]

len_DNA = len(DNA)

alphabet = [ "A", "C", "G", "T"]

alpha_dict = { "A": 0, "C": 1, "G": 2, "T": 3 }

motif = []

best_motif = []

motif_score = 0

best_ham = 0



def Score_Motif( motifs, consensus_string ):

  score_motif = 0

  for kmer in motif:

    for i in range( k ):

      if kmer[i] != consensus_string[i]:

        score_motif += 1

  return score_motif



def Find_Profile( motifs, position ):


  for i in range( len_DNA - position ):

    freq_table = {}

    for j in range( 1, len( DNA[0] ) - k + 1):

      motif_i_trial = DNA[ position + i ][ j:(j + k) ]

      freq_table[ motif_i_trial ] = HammingDistanceArray( motif[0:position], motif_i_trial )

    motif[ i + position ] = min( freq_table, key=freq_table.get )


def Find_Profile2( motifs, position ):


  # Generate a blank profile matrix.
  profile = [ ]

  consensus_string = ""

  consensus_prob = []

  for nuc in alphabet:

    blank_kmer = [ 1 for i in range( k ) ]

    for mot in motifs[ 0:position ]:

      for j in range( k ):

        if mot[ j ] == nuc:

          blank_kmer[ j ] += 1

    profile.append( blank_kmer )


  for i in range( k ):

    total_freq = profile[ 0 ][ i ] + profile[ 1 ][ i ] + profile[ 2 ][ i ] + profile[ 3 ][ i ]

    for j in range( 4 ):

      profile[ j ][ i ] = profile[ j ][ i ] / total_freq

      consensus_prob.append( profile[ j ][ i ] )

    consensus_string += list(alpha_dict.keys())[consensus_prob.index( max( consensus_prob ) )]
    consensus_prob = []
  

  # Need to check whether this piece of code works.
  for i in range( len_DNA - position ):

    freq_table = {}

    for j in range( 0, len( DNA[0] ) - k + 1):

      motif_i_trial = DNA[ position + i ][ j:(j + k) ]

      prob = 1

      for p in range( k ):

        # There may be an error here. 
        prob *= profile[ alpha_dict[ motif_i_trial[ p ] ]  ] [ p ]

      freq_table[ motif_i_trial ] = 1 - prob

    motif[ i + position ] = min( freq_table, key=freq_table.get )


  return consensus_string



# Crafting the initial motif matrix.
motif = initial_motif_matrix

#best_ham = HammingDistanceArray( motif[ 0:len_DNA ], motif[ 0 ] )


profile = [ ]

consensus_string = ""

consensus_prob = []

for nuc in alphabet:

  blank_kmer = [ 1 for i in range( k ) ]

  for mot in motif:

    for j in range( k ):

      if mot[ j ] == nuc:

        blank_kmer[ j ] += 1

  profile.append( blank_kmer )


for i in range( k ):

  total_freq = profile[ 0 ][ i ] + profile[ 1 ][ i ] + profile[ 2 ][ i ] + profile[ 3 ][ i ]

  #print( 'Profile matrix before modification: ', profile )

  for j in range( 4 ):

    profile[ j ][ i ] = profile[ j ][ i ] / total_freq

    consensus_prob.append( profile[ j ][ i ] )

  #print( 'Profile matrix after modification: ', profile )

  #consensus_string += list(alpha_dict.keys())[list(alpha_dict.values()).index( max( consensus_prob ) )]

  #consensus_string += list(alpha_dict.keys())[consensus_prob.index( max( consensus_prob ) )]
  consensus_string += alphabet[consensus_prob.index( max( consensus_prob ) )]
  consensus_prob = []

  #print( consensus_string )

print( 'profile matrix: ', profile )

best_score = Score_Motif( motif, consensus_string )

print( "Initial motif: ", motif )


for j in range( 1, (len( DNA[0] ) - k + 1) ):

  motif[ 0 ] = DNA[ 0 ][ j:(j + k) ]

  #print( motif[ 0 ] )

  #print( DNA[0], DNA[ 0 ][ j:(j + k) ] )

  for i in range( 1, len_DNA ):

    # I don't understand whats going on here.
    consensus_string = Find_Profile2( motif, i )
    
  Motif_score = Score_Motif( motif, consensus_string )
  #print( "\n", motif, " ", Motif_score, " ", consensus_string )

  if best_score > Motif_score:

    best_motif = motif.copy()
    best_score = Motif_score

  #print( "\n Motif: ", motif )

  #print( "\n   Best motif: ", best_motif )

print( best_motif )

"""# Finding the positions of each of the k-mers identified within the genome."""

for i in range( len( DNA ) ):

  print( DNA[ i ].find( best_motif[ i ] ) )